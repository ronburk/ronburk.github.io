<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style>
code {
    font-size: .8rem;
}
h1 {
    font-size: 1.2rem;
}
code.block {
    background-color: #BBB;
    border: 1px solid #999;
    display: block;
    font-family: monospace;
    padding: .2em;
    white-space: pre;
}

code.inline {
    display: block;
    font-family: monospace;
    white-space: pre;
    }
p {
    margin-top: 12px;
    margin-bottom: 12px;
}    

    /* Simple dashboard grid CSS */

    /* Assign grid instructions to our parent grid container */
    .grid-container {
      display: grid;
      grid-template-columns: 240px 1fr;
      grid-template-rows: 50px 1fr 50px;
      grid-template-areas:
        "sidenav header"
        "sidenav main"
        "sidenav footer";
      height: 100vh;
    }

    /* Give every child element its grid name */
    .header {
      grid-area: header;
      background-color: #648ca6;
    }

    .sidenav {
      grid-area: sidenav;
      background-color: #394263;
    }

    .main {
      grid-area: main;
      background-color: #8fd4d9;
      padding-left: 1.5em;
      padding-right: 2em;
      padding-bottom: 2em;
    }

    .footer {
      grid-area: footer;
      background-color: #648ca6;
    }

  .sidenav {
    display: flex; /* Will be hidden on mobile */
    flex-direction: column;
    grid-area: sidenav;
    background-color: #394263;
  }
  .sidenav__list {
    padding: 0;
    margin-top: 85px;
    list-style-type: none;
  }
  .sidenav__list-item {
    padding: 20px 20px 20px 40px;
    color: #ddd;
  }
  .sidenav__list-item:hover {
    background-color: rgba(255, 255, 255, 0.2);
    cursor: pointer;
  }



/* [COLLAPSIBLE] */
#menutree label {
  position: relative;
  display: block;
  width: 100%;
  cursor: pointer;
}
#menutree {
  list-style-type: none;
  padding-left: 3px;
  margin: 0;
  font-size: smaller;
}

#menutree, #menutree ul {
  list-style-type: none;
  padding-left: 1em;
  margin: 0;
}
#menutree input[type=checkbox] {
  display: none; /* Hide ugly checkbox */
}

#menutree a, #menutree a:visited {
  color: white;
  text-decoration: none;
}
/* Hide/collapse by default */
li.collapse ul {
  visibility: hidden;
  opacity: 0;
  max-height: 0; /* CSS bug. Cannot animate height... */
  transition: all 0.5s;
}
label::before {
  content: "\25b6";
  position: absolute;
  top: 0;
  right: 0;
  transition: all 0.5s;
}

/* Show when checked */
li.collapse input:checked ~ ul {
  visibility: visible;
  opacity: 1;
  max-height: 999px; /* Just give a big enough height for animation */
}
li.collapse input:checked ~ label::before {
  transform: rotate(90deg);
  }

  .header, .footer {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 16px;
    background-color: #648ca6;
  }

blockquote {
  background: #f9f9f9;
  border-left: 10px solid #ccc;
  margin: 1.5em 10px;
  padding: 0.5em 10px;
  quotes: "\201C""\201D""\2018""\2019";
}
blockquote:before {
  color: #ccc;
  content: open-quote;
  font-size: 4em;
  line-height: 0.1em;
  margin-right: 0.25em;
  vertical-align: -0.4em;
}
blockquote p {
  display: inline;
}
</style>
<script>
            function InitNav(){
                //document.getElementsByClassName("open-on-load").checked = true;
                let nodes = document.getElementsByClassName("open-on-load");
                for(let i = 0; i < nodes.length; ++i){
                    nodes[i].click();
                    }
                }
                window.onload = InitNav;
        </script>
</head>
<body>
<div class="grid-container">
<header class="header">
        Module Cycles
    </header>
<aside class="sidenav">
<noscript><b>JavaScript disabled, menu in uncool mode</b></noscript>
<ul id="menutree"><li class="collapse">
<input type="checkbox" id="idp1" class="open-on-load"><label for="idp1"></label><a href="/index.html">Ron Burk github pages</a><ul>
    <li class="collapse">
<input type="checkbox" id="idp2" class="open-on-load"><label for="idp2"></label><a href="/v8/index.html">
        Stumbling Around V8
    </a><ul>
        <li><a href="/v8/threads.html">
        V8: Single- and Multi-Threaded
    </a></li>
        <li><a href="/v8/building.html">
        Building the Damn Thing
    </a></li>
        <li class="collapse">
<input type="checkbox" id="idp3" class="open-on-load"><label for="idp3"></label><a href="/v8/modules/index.html">
        Modules
    </a><ul>
            <li><a href="/v8/modules/spec-says.html">
            Language Specification Says...
        </a></li>
            <li><a href="/v8/modules/cycles.html">
        Module Cycles
    </a></li>
            <li><a href="/v8/modules/d8.html">
        How d8 Loads Modules
    </a></li>
        </ul>
</li>
    </ul>
</li>
</ul>
</li></ul>
</aside>
<main class="main"><h1>Module Cycles</h1>
<p>
        If you make a graph with JavaScript modules as nodes and
        viewing their contained import statements as "arrows"
        pointing at other nodes,
        you can end up with cycles in your graph.
        A simple example is you import "a.js" which itself
        imports "b.js", which in turn happens to be
        importing some functions from "a.js".
        This is another reason you will be writing code that detects
        when a module has already been loaded.
    </p>
<p>
        <a href="https://exploringjs.com/impatient-js/ch_modules.html#esms-transparent-support-for-cyclic-imports-advanced">JavaScript for impatient programmers says the language</a>
        <blockquote>
            supports cyclic imports transparently.
        </blockquote>
        and also:
        <blockquote>
            handles cyclic imports correctly.
        </blockquote>
        I feel dubious because I'm pretty sure I can
        construct a mutual dependence between modules
        that has no correct meaning
        (but maybe I just have
        <a href="https://en.wikipedia.org/wiki/Entscheidungsproblem">Entscheidungsproblem</a>
        on the brain).
    </p>
<p>
        To see what I mean, here's "a.mjs":
        <pre><code>
            /* module a */
            import {b} from "b.mjs";

            export let aval = b(45);
        </code></pre>
        and here's "b.mjs":
        <pre><code>
            /* module b */
            import {aval} from "a.mjs";
            export function b(num) { return aval + 1; }
        </code></pre>
        Remember that part of making a module ready to use
        is "evaluating" it (executing its code).
        Evaluating "a.mjs" requires calling function
        <code>b()</code> from "b.mjs".
        Now, a smart human could look at this and say
        <q>hey, this can work if you evaluate "b.mjs" first!</q>
        See, evaluating "a.mjs" absolutely requires executing a
        call to <code>b(45)</code>,
        and we don't get to execute code from module "b.mjs"
        until that module has been evaulated.
        So clearly we can't evaluate "a.mjs" first.
        What if we evaluate "b.mjs" first?
        In this case, 
    </p>
<p>
        The first time JavaScript encounters an "import" statement,
        that could lead to a pretty long list of modules to import.
        In other words, the first module may import from other modules
        that in turn import from still other modules.
        This is most naturally defined as a recursive process that
        stops recursing when it hits modules that import no
        modules that have not already been loaded.
        However, just to be contrary, I will implement a non-recursive
        module load.
    </p>
<p>
    </p>
</main>
<footer class="footer"><div>NEXT: <a href="/v8/modules/d8.html">
        How d8 Loads Modules
    </a>
</div>
<div>
            UP:
            <a href="/v8/modules/index.html">
        Modules
    </a>
</div>
<div>PREV: <a href="/v8/modules/spec-says.html">
            Language Specification Says...
        </a>
</div></footer>
</div>
</body>
</html>
